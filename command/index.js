const shell=require("shelljs"),path=require("path"),compressing=require("compressing"),NodeSSH=require("node-ssh")["NodeSSH"],fs=require("fs-extra"),logger=require("../javascript/console");module.exports={setGitConfig(body){return new Promise(async(resolve,reject)=>{let gitUrl=body.git.url,webUrl=gitUrl.slice(gitUrl.indexOf("//")+2,gitUrl.length);webUrl=webUrl.slice(0,webUrl.indexOf("/")),await logger.info({...body,message:"Setting git access..."}),await fs.outputFile("/root/.gitconfig",`[credential] 
  helper = store`).catch(async error=>{await logger.error({...body,message:error}),await logger.error({...body,message:"Git login certificate gitconfig setting failed！"}),reject()});var http=gitUrl.slice(0,gitUrl.indexOf("//"));await fs.outputFile("/root/.git-credentials",`${http}//${body.git.username}:${body.git.password}@`+webUrl).then(async()=>{resolve()}).catch(async error=>{await logger.error({...body,message:error}),await logger.error({...body,message:"Git credentials setting failed！"}),reject()})})},cloneProject(body){return new Promise(async(resolve,reject)=>{await logger.info({...body,message:"Cloning project from git, please wait..."});var result=path.join(__dirname,"../project/"+body.bid);await fs.ensureDir(result).catch(async err=>{await logger.error({...body,message:err}),reject(err)});result=await shell.exec(`git clone -b ${body.git.branch} `+body.git.url,{cwd:result});await logger.exec(body,result).then(()=>{resolve()}).catch(()=>{reject("Project cloning failed！")})})},pullBackProject:async body=>new Promise(async(resolve,reject)=>{await logger.info({...body,message:"pulling project from git, please wait..."});var result=path.join(__dirname,`../project/${body.bid}/`+body.projectName),result=await shell.exec("git pull",{cwd:result});await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject("Project pull failed！")})}),initPackage:body=>new Promise(async(resolve,reject)=>{await logger.info({...body,message:"Installing project dependencies, please wait..."});var result=path.join(__dirname,`../project/${body.bid}/`+body.projectName),result=await shell.exec(body.install,{cwd:result});await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject("Project dependency installation failed！")})}),buildProject:body=>new Promise(async(resolve,reject)=>{await logger.info({...body,message:"Packaging project, please wait..."});var result=path.join(__dirname,`../project/${body.bid}/`+body.projectName),result=await shell.exec(body.build,{cwd:result});await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject("Project packaging failed！")})}),deleteProject:body=>new Promise(async(resolve,reject)=>{if(await logger.info({...body,message:"Deleting project directory, please wait..."}),!body.projectName){let gitUrl=body.git.url,projectName=gitUrl.slice(gitUrl.lastIndexOf("/")+1,gitUrl.lastIndexOf("."));body.projectName=projectName.replace("*","")}var result=path.join(__dirname,`../project/${body.bid}/`+body.projectName),result=await shell.rm("-rf",result);await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject("This project cannot be found, deletion failed!")})}),deleteBackup:body=>new Promise(async(resolve,reject)=>{await logger.info({...body,message:"Deleting project backup directory, please wait..."});var result=path.join(__dirname,"../backup/"+body.bid),result=await shell.rm("-rf",result);await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject("This project backup cannot be found, deletion failed!")})}),deleteWww:body=>new Promise(async(resolve,reject)=>{var result;await logger.info({...body,message:"Deleting www directory, please wait..."}),-1==body.www.indexOf("*")?(result=path.join(__dirname,"../www/"+body.www),result=await shell.rm("-rf",result),await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject("This www cannot be found, deletion failed!")})):reject(NaN)}),deleteLog:body=>new Promise((resolve,reject)=>{var result=path.join(__dirname,"../console/"+body.bid),result=shell.rm("-rf",result);console.log(result.stdout),console.log(result.stderr),(0==result.code?resolve:reject)()}),deleteNodeModule:(body,res)=>new Promise(async(resolve,reject)=>{var result;await logger.info({...body,message:'Deleting project dependent package "node_modules", please wait...'}),body.projectName?(result=path.join(__dirname,`../project/${body.bid}/${body.projectName}/node_modules`),result=await shell.rm("-rf",result),await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject("This node_modules cannot be found, deletion failed!")})):reject("This node_modules cannot be found, deletion failed!")}),copyPackage:body=>new Promise(async(resolve,reject)=>{await logger.info({...body,message:"Back up the package.json file."});var packagePath=path.join(__dirname,`../project/${body.bid}/${body.projectName}/package.json`),result=path.join(__dirname,"../console/"+body.bid);await fs.ensureDir(result).catch(async err=>{await logger.error({...body,message:err}),reject(err)});result=await shell.cp(packagePath,result);await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject('This "package.json" cannot be found, backup failed!')})}),backupDist:body=>new Promise(async(resolve,reject)=>{await logger.info({...body,commitBid:body.commitBid,message:"Backup package folder."});var distPath=path.join(__dirname,`../project/${body.bid}/${body.projectName}/`+body.dist),result=path.join(__dirname,`../backup/${body.bid}/`+body.commitBid);await fs.ensureDir(result).catch(async err=>{await logger.error({...body,message:err}),reject(err)});result=await shell.cp("-rf",distPath,result);await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject("Dist package backup failed!")})}),moveBackupToWww:body=>new Promise(async(resolve,reject)=>{await logger.info({...body,commitBid:body.commitBid,message:"Copy the package file to the deployment root directory."}),"2"!=body.type&&"4"!=body.type||(body.dist="dist");var result=path.join(__dirname,`../backup/${body.bid}/${body.commitBid}/${body.dist}/*`),wwwPath=path.join(__dirname,"../www/"+body.www);if(fs.existsSync(wwwPath)){let result=await shell.rm("-rf",wwwPath);await logger.exec(body,result).catch(()=>{reject("Failed to empty the root directory in the project")})}await fs.ensureDir(wwwPath).catch(async err=>{await logger.error({...body,message:err}),reject(err)});result=await shell.cp("-rf",result,wwwPath);await logger.exec(body,result).then(res=>{resolve()}).catch(()=>{reject("An error occurred while the dist package was moving the root directory!")})}),compressingBuildFile:body=>new Promise(async(resolve,reject)=>{await logger.info({...body,message:"Compressing packed files..."});var filePath1=path.join(__dirname,`../backup/${body.bid}/`+body.commitBid),filePath2=path.join(__dirname,`../backup/${body.bid}/dist.zip`);await compressing.zip.compressDir(filePath1,filePath2).then(async()=>{await logger.info({...body,message:"Package file compressed successfully."}),resolve()}).catch(async error=>{await logger.error({...body,message:error}),reject()})}),connectSSH:body=>new Promise(async(resolve,reject)=>{const ssh=new NodeSSH;await logger.info({...body,message:"Connecting to remote server, please wait..."});var type=body.ssh.password?"password":"privateKey";let obj={host:body.ssh.host,username:body.ssh.username,port:body.port,[type]:body.ssh.password||body.ssh.privateKey};body.ssh.readyTimeout&&(obj.readyTimeout=body.ssh.readyTimeout),await ssh.connect(obj).then(async()=>{global.store.ssh[body.bid]=ssh,await logger.info({...body,message:"Remote server connected successfully"}),resolve()}).catch(async error=>{await logger.error({...body,message:error}),await logger.error({bid:body.bid,commitBid:body.commitBid,message:"SSH connection failed（ Possible reasons: 1: wrong password, 2: wrong private key address, 3: the server does not configure the local public key."}),reject()})}),putFolderSSh:body=>new Promise(async(resolve,reject)=>{const ssh=global.store.ssh[body.bid];await logger.info({...body,message:"Uploading compressed file, please wait..."});const failed=[],successful=[],filePath=path.join(__dirname,`../backup/${body.bid}/`+body.commitBid);await ssh.putDirectory(filePath,"/"+body.www,{recursive:!0,concurrency:12,validate:itemPath=>{return"node_modules"!==path.basename(itemPath)},tick:async(localPath,remotePath,error)=>{localPath=localPath.replace(filePath,""),error?(await logger.error({...body,message:error}),failed.push(localPath)):(await logger.info({...body,message:`File '${localPath}' uploaded successfully`}),successful.push(localPath))}}).then(async status=>{await logger.info({...body,message:`The package file has been uploaded to the specified directory and deployed ${status?"successful":"unsuccessful"}.`}),resolve()}).catch(async error=>{await logger.error({...body,message:error}),reject()})}),putFilesSSh:body=>new Promise(async(resolve,reject)=>{const ssh=global.store.ssh[body.bid];await logger.info({...body,message:"Uploading compressed file, please wait..."}),await ssh.putFiles([{local:path.join(__dirname,`../backup/${body.bid}/dist.zip`),remote:`/${body.www}/build/dist.zip`}]).then(async()=>{await logger.info({...body,message:"The compressed file has been uploaded to the remote server successfully"}),resolve()}).catch(async error=>{await logger.error({...body,message:error}),reject()})}),moveAllFileOutdist:(body,res)=>new Promise(async(resolve,reject)=>{const ssh=global.store.ssh[body.bid];await logger.info({...body,message:"Move all files outside the dist folder."}),await ssh.execCommand(`mv -f ./${body.dist}/* ./`,{cwd:"/"+body.www}).then(async result=>{result.stdout&&await logger.info({...body,message:result.stdout}),result.stderr&&await logger.info({...body,message:result.stderr}),resolve()}).catch(async error=>{await logger.error({...body,message:error}),reject()})}),deleteAllDistFile:(body,res)=>new Promise(async(resolve,reject)=>{const ssh=global.store.ssh[body.bid];body.www?"/"!=body.www&&-1==body.www.indexOf("*")&&-1==body.www.indexOf(".")?(await logger.info({...body,message:"Emptying existing old files..."}),await ssh.execCommand("rm -rf ./*",{cwd:"/"+body.www}).then(async result=>{result.stdout&&await logger.info({...body,message:result.stdout}),result.stderr&&await logger.info({...body,message:result.stderr}),resolve()}).catch(async error=>{await logger.error({...body,message:error}),reject()})):await logger.warning({...body,message:'It is found that the deployment path contains the dangerous character "*" or "..", please check, dangerous operation!'}):await logger.warning({...body,message:"It is found that the deployment path is empty, please check, dangerous operation!"})}),undoZipFile:(body,res)=>new Promise(async(resolve,reject)=>{const ssh=global.store.ssh[body.bid];await logger.info({...body,message:"Extracting remote package file, please wait..."}),await ssh.exec("unzip -o dist.zip",[],{cwd:"/"+body.www}).then(async()=>{await logger.info({...body,message:"Remote zip decompression succeeded"}),resolve()}).catch(async error=>{await logger.error({...body,message:error}),reject()})})};